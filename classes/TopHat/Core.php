<?php
/**
 * Core class file
 *
 * Includes a series of static methods and constants,
 * for general use
 *
 * PHP Version 5.3
 *
 * @package  TopHat
 * @author   Shaun Persad <shaunpersad@gmail.com>
 * @license  http://opensource.org/licenses/gpl-license.php GNU Public License
 * @link     http://shaunpersad.com
 */

namespace TopHat;

use Doctrine\Common\Cache\MemcachedCache;
use Doctrine\Common\Cache\XcacheCache;
use Doctrine\DBAL\Configuration;
use Doctrine\DBAL\DriverManager;
use Doctrine\Common\Cache\ApcCache;
use Doctrine\Common\Cache\MemcacheCache;
use Doctrine\DBAL\Connection;
use Phpass\Hash;
use Solarium;
use Memcache;
use Memcached;
use Valitron\Validator;

/**
 * Class Core
 * @package TopHat
 */
class Core {

    const STATUS_DELETED = 1;
    const STATUS_DRAFT = 2;
    const STATUS_PENDING = 3;
    const STATUS_PUBLISHED = 4;
    //const STATUS_FUTURE = 5;

    public static $statuses = array(
        self::STATUS_DRAFT => 'draft',
        self::STATUS_PENDING => 'pending',
        self::STATUS_PUBLISHED => 'published',
        self::STATUS_DELETED => 'deleted'

    );

    const ALERT_TYPE_ERROR = 'error';
    const ALERT_TYPE_SUCCESS = 'success';
    const ALERT_TYPE_WARNING = 'warning';
    const ALERT_TYPE_EXCEPTION = 'exception';

    protected static $alerts;
    protected static $db;
    protected static $cache;
    protected static $current_user;


    /**
     * @return string The session id.
     */
    public static function startSession() {

        if(!isset($_SESSION)) {
            session_start();

            if (!isset($_SESSION['__alerts'])) {

                $_SESSION['__alerts'] = array();
            }
        }
        return session_id();
    }


    /**
     * @return array[] An associative array of arrays, indexed by alert type.
     */
    public static function getAllAlerts() {

        self::startSession();

        $all_alerts = $_SESSION['__alerts'];

        self::resetAlerts();

        return $all_alerts;
    }

    /**
     * @param string $type Preferably an ALERT_TYPE constant.
     * @return string[] An array of messages.
     */
    public static function getAlertsForType($type) {

        self::startSession();

        $alerts_for_type = array();

        if (!empty($_SESSION['__alerts'][$type])) {

            $alerts_for_type = $_SESSION['__alerts'][$type];
            self::resetAlerts($type);
        }
        return $alerts_for_type;
    }

    /**
     * @param string $type If specified, will reset only for that type.
     * @return void
     */
    public static function resetAlerts($type = '') {

        self::startSession();

        if (!empty($type)) {

            unset($_SESSION['__alerts'][$type]);
            $_SESSION['__alerts'][$type] = array();
        } else {
            unset($_SESSION['__alerts']);
            $_SESSION['__alerts'] = array();
        }
    }

    /**
     * @param string $message The message to add.
     * @param string $type Preferably an ALERT_TYPE constant.
     */
    public static function addAlert($message, $type = self::ALERT_TYPE_ERROR) {

        self::startSession();

        $_SESSION['__alerts'][$type][] = $message;

    }


    /**
     * For adding the validation errors generated by Valitron.
     */
    public static function addValidationAlerts($validation_errors) {

        foreach ($validation_errors as $errors) {

            foreach ($errors as $error) {

                self::addAlert($error, self::ALERT_TYPE_ERROR);
            }
        }
    }

    /**
     * @return Connection|mixed Database object.
     */
    public static function getDb() {

        if (empty(self::$db)) {

            $config = new Configuration();

            $db_params = array(
                'dbname' => DB_NAME,
                'user' => DB_USER,
                'password' => DB_PASSWORD,
                'host' => DB_HOST,
                'driver' => DB_DRIVER
            );

            /*
             * Doctrine DBAL database object.
             * Documentation here:
             * http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/data-retrieval-and-manipulation.html
             */
            $db = DriverManager::getConnection($db_params, $config);

            self::$db = $db;
        }

        return self::$db;
    }

    /**
     * @param mixed $db
     */
    public static function setDb($db) {

        self::$db = $db;
    }

    /**
     * Gets a Post via either an id or slug.
     *
     * Uses write-through caching.
     *
     * @param int|string $post_identifier The id or slug.
     * @return Post|false
     */
    public static function getPost($post_identifier) {

        $db = self::getDb();
        $cache = self::getCache();
        $post = false;
        $key = 'post/'.$post_identifier;

        if ($cache) {
            $post = $cache->fetch($key);
        }

        if (!$post) {

            $post_data = array();

            if (is_numeric($post_identifier)) {

                $sql = 'SELECT * FROM posts WHERE id = ?';
                $post_data = $db->fetchAssoc($sql, array($post_identifier), array(\PDO::PARAM_INT));


            } else {

                $sql = 'SELECT * FROM posts WHERE slug = ?';
                $post_data = $db->fetchAssoc($sql, array($post_identifier), array(\PDO::PARAM_STR));

            }

            if (!empty($post_data)) {

                $post = new Post($post_data);

                if ($cache) {
                    $cache->save('post/'.$post->id, $post);
                    $cache->save('post/'.$post->slug, $post);
                }

            }
        }

        return $post;
    }

    /**
     * Query builder to get posts.
     *
     * Pass arguments as an associative array to control the query.  See documentation for currently supported args.
     * Uses generational caching.
     *
     * @param array $args
     * @return Post[]|int
     */
    public static function getPosts($args = array()) {

        $db = self::getDb();
        $cache = self::getCache();
        $posts = false;
        $args = self::filterArgsArrays($args);
        $key = 'posts/'.self::getGenerationForDataType('post').'/'.serialize($args);

        if ($cache) {

            $posts = $cache->fetch($key);
        }

        if (!$posts) {

            $posts = array();

            $distinct = true;
            $count_only = false;
            $page = 1;
            $per_page = 30;
            $status = self::STATUS_PUBLISHED;
            $order_by = 'posts.date_published';
            $order_dir = 'DESC';

            extract($args);

            if (empty($order_dir) || $order_dir != 'DESC') {
                $order_dir = 'ASC';
            }

            $sql = 'SELECT';

            if ($distinct) {

                $sql.= ' DISTINCT';
            }

            $sql.= ' posts.*, users.display_name AS author_display_name FROM posts';

            $joins = array('users' => 'posts.author_id = users.id');

            $where = array();
            $data = array();
            $types = array();

            /*
             * AUTHOR ID
             */
            if (!empty($author_id)) {

                $where[] = 'posts.author_id = ?';
                $data[] = $author_id;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($author_id_in)) {

                $where[] = 'posts.author_id IN (?)';
                $data[] = $author_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($author_id_not_in)) {

                $where[] = 'posts.author_id NOT IN (?)';
                $data[] = $author_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END AUTHOR ID
             */

            /*
             * AUTHOR EMAIL
             */
            if (!empty($author_email)) {

                $where[] = ' users.email = ?';
                $data[] = $author_email;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($author_email_in)) {

                $where[] = 'users.email IN (?)';
                $data[] = $author_email_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($author_email_not_in)) {

                $where[] = 'users.email NOT IN (?)';
                $data[] = $author_email_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END AUTHOR EMAIL
             */

            /*
             * CATEGORY ID
             */
            if (!empty($category_id)) {

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $where[] = 'posts_categories.category_id = ?';
                $data[] = $category_id;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($category_id_in)) {

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $where[] = 'posts_categories.category_id IN (?)';
                $data[] = $category_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($category_id_not_in)) {

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $where[] = 'posts_categories.category_id NOT IN (?)';
                $data[] = $category_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($category_id_and)) {

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $local_where = array();

                foreach ($category_id_and as $category_id) {

                    $local_where[] = 'posts_categories.category_id = ?';
                    $data[] = $category_id;
                    $types[] = \PDO::PARAM_INT;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END CATEGORY ID
             */

            /*
             * CATEGORY SLUG
             */
            if (!empty($category_slug)) {

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $joins['categories'] = 'posts_categories.category_id = categories.id';

                $where[] = 'categories.slug = ?';
                $data[] = $category_slug;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($category_slug_in)) {

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $joins['categories'] = 'posts_categories.category_id = categories.id';

                $where[] = 'categories.slug IN (?)';
                $data[] = $category_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($category_slug_not_in)) {

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $joins['categories'] = 'posts_categories.category_id = categories.id';

                $where[] = 'categories.slug NOT IN (?)';
                $data[] = $category_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($category_slug_and)) {

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $joins['categories'] = 'posts_categories.category_id = categories.id';

                $local_where = array();

                foreach ($category_slug_and as $category_slug) {

                    $local_where[] = 'categories.slug = ?';
                    $data[] = $category_slug;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END CATEGORY SLUG
             */

            /*
             * SECTION ID
             */
            if (!empty($section_id)) {

                $joins['posts_sections'] = 'posts.id = posts_sections.post_id';
                $where[] = 'posts_sections.section_id = ?';
                $data[] = $section_id;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($section_id_in)) {

                $joins['posts_sections'] = 'posts.id = posts_sections.post_id';
                $where[] = 'posts_sections.section_id IN (?)';
                $data[] = $section_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($section_id_not_in)) {

                $joins['posts_sections'] = 'posts.id = posts_sections.post_id';
                $where[] = 'posts_sections.section_id NOT IN (?)';
                $data[] = $section_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($section_id_and)) {

                $joins['posts_sections'] = 'posts.id = posts_sections.post_id';
                $local_where = array();

                foreach ($section_id_and as $section_id) {

                    $local_where[] = 'posts_sections.section_id = ?';
                    $data[] = $section_id;
                    $types[] = \PDO::PARAM_INT;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END SECTION ID
             */

            /*
             * SECTION SLUG
             */
            if (!empty($section_slug)) {

                $joins['posts_sections'] = 'posts.id = posts_sections.post_id';
                $joins['sections'] = 'posts_sections.section_id = sections.id';

                $where[] = 'sections.slug = ?';
                $data[] = $section_slug;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($section_slug_in)) {

                $joins['posts_sections'] = 'posts.id = posts_sections.post_id';
                $joins['sections'] = 'posts_sections.section_id = sections.id';

                $where[] = 'sections.slug IN (?)';
                $data[] = $section_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($section_slug_not_in)) {

                $joins['posts_sections'] = 'posts.id = posts_sections.post_id';
                $joins['sections'] = 'posts_sections.section_id = sections.id';

                $where[] = 'sections.slug NOT IN (?)';
                $data[] = $section_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($section_slug_and)) {

                $joins['posts_sections'] = 'posts.id = posts_sections.post_id';
                $joins['sections'] = 'posts_sections.section_id = sections.id';

                $local_where = array();

                foreach ($section_slug_and as $section_slug) {

                    $local_where[] = 'sections.slug = ?';
                    $data[] = $section_slug;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END SECTION SLUG
             */

            /*
             * POST ID
             */
            if (!empty($post_id_in)) {

                $where[] = 'posts.id IN (?)';
                $data[] = $post_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($post_id_not_in)) {

                $where[] = 'posts.id NOT IN (?)';
                $data[] = $post_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            /*
             * END POST ID
             */

            /*
             * POST SLUG
             */
            if (!empty($post_slug_in)) {

                $where[] = 'post.slug IN (?)';
                $data[] = $post_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($post_slug_not_in)) {

                $where[] = 'post.slug NOT IN (?)';
                $data[] = $post_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            /*
             * END POST SLUG
             */

            /*
             * META TITLE
             */
            if (!empty($meta_title)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.title = ?';
                $data[] = $meta_title;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($meta_title_in)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.title IN (?)';
                $data[] = $meta_title_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_title_not_in)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.title NOT IN (?)';
                $data[] = $meta_title_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_title_and)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';

                $local_where = array();

                foreach ($meta_title_and as $meta_title) {

                    $local_where[] = 'posts_meta.title = ?';
                    $data[] = $meta_title;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END META TITLE
             */

            /*
             * META VALUE
             */
            if (!empty($meta_value)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.value = ?';
                $data[] = $meta_value;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($meta_value_in)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.value IN (?)';
                $data[] = $meta_value_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_value_not_in)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.value NOT IN (?)';
                $data[] = $meta_value_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_value_and)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';

                $local_where = array();

                foreach ($meta_value_and as $meta_value) {

                    $local_where[] = 'posts_meta.value = ?';
                    $data[] = $meta_value;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END META VALUE
             */

            /*
             * META TYPE
             */
            if (!empty($meta_type)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.type = ?';
                $data[] = $meta_type;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($meta_type_in)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.type IN (?)';
                $data[] = $meta_type_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_type_not_in)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';
                $where[] = 'posts_meta.type NOT IN (?)';
                $data[] = $meta_type_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_type_and)) {

                $joins['posts_meta'] = 'posts.id = posts_meta.post_id';

                $local_where = array();

                foreach ($meta_type_and as $meta_type) {

                    $local_where[] = 'posts_meta.type = ?';
                    $data[] = $meta_type;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END META TYPE
             */

            /*
             * TAG ID
             */
            if (!empty($tag_id)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $where[] = ' posts_tags.tag_id = ?';
                $data[] = $tag_id;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($tag_id_in)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $where[] = 'posts_tags.tag_id IN (?)';
                $data[] = $tag_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($tag_id_not_in)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $where[] = 'posts_tags.tag_id NOT IN (?)';
                $data[] = $tag_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($tag_id_and)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $local_where = array();

                foreach ($tag_id_and as $tag_id) {

                    $local_where[] = 'posts_tags.tag_id = ?';
                    $data[] = $tag_id;
                    $types[] = \PDO::PARAM_INT;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END TAG ID
             */

            /*
             * TAG TITLE
             */
            if (!empty($tag_title)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $joins['tags'] = 'posts_tags.tag_id = tags.id';

                $where[] = 'tags.title = ?';
                $data[] = $tag_title;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($tag_title_in)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $joins['tags'] = 'posts_tags.tag_id = tags.id';

                $where[] = 'tags.title IN (?)';
                $data[] = $tag_title_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($tag_title_not_in)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $joins['tags'] = 'posts_tags.tag_id = tags.id';

                $where[] = 'tags.title NOT IN (?)';
                $data[] = $tag_title_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($tag_title_and)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $joins['tags'] = 'posts_tags.tag_id = tags.id';

                $local_where = array();

                foreach ($tag_title_and as $tag_title) {

                    $local_where[] = 'tags.title = ?';
                    $data[] = $tag_title;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END TAG TITLE
             */

            /*
             * STATUS
             */
            if (!empty($status)) {

                $where[] = 'posts.status = ?';
                $data[] = $status;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($status_in)) {

                $where[] = 'posts.status IN(?)';
                $data[] = $status_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($status_not_in)) {

                $where[] = 'posts.status NOT IN(?)';
                $data[] = $status_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END STATUS
             */

            /*
             * SEARCH QUERY
             */
            if (!empty($s)) {

                $joins['posts_tags'] = 'posts.id = posts_tags.post_id';
                $joins['tags'] = 'posts_tags.tag_id = tags.id';

                $joins['posts_categories'] = 'posts.id = posts_categories.post_id';
                $joins['categories'] = 'posts_categories.category_id = categories.id';

                $where[] = '(posts.title LIKE ?
                            OR posts.body LIKE ?
                            OR posts.teaser LIKE ?
                            OR tags.title LIKE ?
                            OR categories.title LIKE ?)';

                for ($x = 0; $x < 5; $x++) {

                    $data[] = '%'.$s.'%';
                    $types[] = \PDO::PARAM_STR;
                }

            }
            /*
             * END SEARCH QUERY
             */


            $limit = intval($per_page);
            $start = intval(($page - 1) * $limit);

            $join_query = '';
            $where_query = '';

            foreach ($joins as $table => $on) {

                $join_query.= " LEFT OUTER JOIN $table ON $on";
            }

            if (!empty($where)) {

                $where_query = ' WHERE '.implode(' AND ', $where);
            }


            if ($count_only) {

                $count = 'posts.id';
                if ($distinct) {
                    $count = 'DISTINCT(posts.id)';
                }

                $sql = 'SELECT COUNT('.$count.') AS the_count FROM posts';
                $start = 0;
                $limit = 1;
            }

            $sql.= "$join_query$where_query ORDER BY {$db->quoteIdentifier($order_by)} $order_dir LIMIT $start, $limit";

            $result = $db->executeQuery($sql, $data, $types);

            if ($count_only && $row = $result->fetch()) {

                $posts = $row['the_count'];
            } else {
                $posts = array();

                while ($post_data = $result->fetch()) {

                    $posts[] = new Post($post_data);
                }
            }

            if ($cache) {
                $cache->save($key, $posts);
            }
        }

        return $posts;
    }


    /**
     * Gets an array of tags based on arguments.
     *
     * Uses generational caching.
     *
     * @param array $args
     * @return array
     */
    public static function getTags($args = array()) {

        $db = self::getDb();
        $cache = self::getCache();
        $tags = false;
        $args = self::filterArgsArrays($args);
        $key = 'tags/'.self::getGenerationForDataType('post').'/'.md5(json_encode($args));

        if ($cache) {

            $tags = $cache->fetch($key);
        }

        if (!$tags) {

            $tags = array();

            $count_only = false;
            $page = 1;
            $per_page = 30;
            $order_by = 'tags.date_created';
            $order_dir = 'DESC';

            extract($args);

            if (empty($order_dir) || $order_dir != 'DESC') {
                $order_dir = 'ASC';
            }

            $sql = 'SELECT tags.* FROM tags';

            $joins = array();
            $where = array();
            $data = array();
            $types = array();

            /*
             * TAG ID
             */

            if (!empty($tag_id_in)) {

                $where[] = 'tags.id IN (?)';
                $data[] = $tag_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($tag_id_not_in)) {

                $where[] = 'tags.id NOT IN (?)';
                $data[] = $tag_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END TAG ID
             */

            /*
             * TAG TITLE
             */

            if (!empty($tag_title_in)) {

                $where[] = 'tags.title IN (?)';
                $data[] = $tag_title_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($tag_title_not_in)) {

                $where[] = 'tags.title NOT IN (?)';
                $data[] = $tag_title_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END TAG TITLE
             */

            /*
             * POST ID
             */
            if (!empty($post_id)) {

                $joins['posts_tags'] = 'tags.id = posts_tags.tag_id';
                $where[] = 'posts_tags.post_id = ?';
                $data[] = $post_id;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($post_id_in)) {

                $joins['posts_tags'] = 'tags.id = posts_tags.tag_id';
                $where[] = 'posts_tags.post_id IN (?)';
                $data[] = $post_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($post_id_not_in)) {

                $joins['posts_tags'] = 'tags.id = posts_tags.tag_id';
                $where[] = 'posts_tags.post_id NOT IN (?)';
                $data[] = $post_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($post_id_and)) {

                $joins['posts_tags'] = 'tags.id = posts_tags.tag_id';
                $local_where = array();

                foreach ($post_id_and as $post_id) {

                    $local_where[] = 'posts_tags.post_id = ?';
                    $data[] = $post_id;
                    $types[] = \PDO::PARAM_INT;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END POST ID
             */

            /*
             * POST SLUG
             */
            if (!empty($post_slug)) {

                $joins['posts_tags'] = 'tags.id = posts_tags.tag_id';
                $joins['posts'] = 'posts_tags.post_id = posts.id';

                $where[] = 'posts.slug = ?';
                $data[] = $post_slug;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($post_slug_in)) {

                $joins['posts_tags'] = 'tags.id = posts_tags.tag_id';
                $joins['posts'] = 'posts_tags.post_id = posts.id';

                $where[] = 'posts.slug IN (?)';
                $data[] = $post_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($post_slug_not_in)) {

                $joins['posts_tags'] = 'tags.id = posts_tags.tag_id';
                $joins['posts'] = 'posts_tags.post_id = posts.id';

                $where[] = 'posts.slug NOT IN (?)';
                $data[] = $post_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($post_slug_and)) {

                $joins['posts_tags'] = 'tags.id = posts_tags.tag_id';
                $joins['posts'] = 'posts_tags.post_id = posts.id';

                $local_where = array();

                foreach ($post_slug_and as $post_slug) {

                    $local_where[] = 'posts.slug = ?';
                    $data[] = $post_slug;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END POST SLUG
             */



            /*
             * SEARCH QUERY
             */
            if (!empty($s)) {

                $where[] = 'tags.title LIKE ?';
                $data[] = '%'.$s.'%';
                $types[] = \PDO::PARAM_STR;
            }
            /*
             * END SEARCH QUERY
             */

            $limit = intval($per_page);
            $start = intval(($page - 1) * $limit);

            $join_query = '';
            $where_query = '';

            foreach ($joins as $table => $on) {

                $join_query.= " LEFT OUTER JOIN $table ON $on";
            }

            if (!empty($where)) {

                $where_query = ' WHERE '.implode(' AND ', $where);
            }


            if ($count_only) {

                $sql = 'SELECT COUNT(tags.id) AS the_count FROM tags';
                $start = 0;
                $limit = 1;
            }

            $sql.= "$join_query$where_query ORDER BY {$db->quoteIdentifier($order_by)} $order_dir LIMIT $start, $limit";

            $result = $db->executeQuery($sql, $data, $types);

            if ($count_only && $row = $result->fetch()) {

                $tags = $row['the_count'];
            } else {
                $tags = array();

                while ($tag_data = $result->fetch()) {

                    $tags[$tag_data['id']] = $tag_data['title'];
                }
            }


            if ($cache) {

                $cache->save($key, $tags);
            }
        }

        return $tags;
    }


    /**
     * Gets the Meta object for a Post.
     *
     * Uses write-through caching.
     *
     * @param int $post_id The Post id.
     * @return Meta
     */
    public static function getPostMeta($post_id) {

        $db = self::getDb();
        $cache = self::getCache();
        $meta = false;
        $key = 'post/'.$post_id.'/meta';

        if ($cache) {

            $meta = $cache->fetch($key);
        }

        if (!$meta || !($meta instanceof Meta)) {

            $meta = new Meta();

            $sql = 'SELECT *
                    FROM posts_meta
                    WHERE post_id = ?
                    ORDER BY id ASC';

            $result = $db->executeQuery($sql, array($post_id), array(\PDO::PARAM_INT));

            while ($meta_data = $result->fetch()) {

                $meta->add($meta_data);
            }

            if ($cache) {
                $cache->save($key, $meta);
            }
        }
        return $meta;
    }

    /**
     * Gets a Media object by id.
     *
     * Uses write-through caching.
     *
     * @param int $media_id The Media id.
     * @return Media|false The applicable inheritor of Media.
     */
    public static function getMedia($media_id) {

        $db = self::getDb();
        $cache = self::getCache();
        $media = false;
        $key = 'media/'.$media_id;

        if ($cache) {
            $media = $cache->fetch($key);
        }

        if (!$media) {

            $media_data = array();

            $sql = 'SELECT * FROM media WHERE id = ?';
            $media_data = $db->fetchAssoc($sql, array($media_id), array(\PDO::PARAM_INT));

            if (!empty($media_data)) {

                $media = Media::createFromData($media_data);
            }

            if ($cache) {
                $cache->save($key, $media);
            }
        }

        return $media;


    }

    /**
     * Gets an array of Media objects based on arguments.
     *
     * Uses generational caching.
     *
     * @param array $args
     * @return Media[]|MediaImage[]|MediaVideo[]|MediaAudio[]|MediaDocument[]|int|mixed
     */
    public static function getMedias($args = array()) {

        $db = self::getDb();
        $cache = self::getCache();
        $medias = false;
        $args = self::filterArgsArrays($args);
        $key = 'medias/'.self::getGenerationForDataType('post').'/'.md5(json_encode($args));

        if ($cache) {

            $medias = $cache->fetch($key);
        }

        if (!$medias) {

            $medias = array();

            $count_only = false;
            $page = 1;
            $per_page = 30;
            $order_by = 'media.date_updated';
            $order_dir = 'DESC';

            extract($args);

            if (empty($order_dir) || $order_dir != 'DESC') {
                $order_dir = 'ASC';
            }

            $sql = 'SELECT media.* FROM media';

            $joins = array();
            $where = array();
            $data = array();
            $types = array();

            /*
             * MEDIA ID
             */

            if (!empty($media_id_in)) {

                $where[] = 'media.id IN (?)';
                $data[] = $media_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($media_id_not_in)) {

                $where[] = 'media.id NOT IN (?)';
                $data[] = $media_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END MEDIA ID
             */

            /*
             * MEDIA SLUG
             */

            if (!empty($media_slug_in)) {

                $where[] = 'media.slug IN (?)';
                $data[] = $media_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($media_slug_not_in)) {

                $where[] = 'media.slug NOT IN (?)';
                $data[] = $media_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END MEDIA SLUG
             */

            /*
             * MEDIA TYPE
             */
            if (!empty($media_type)) {

                $where[] = 'media.type = ?';
                $data[] = $media_type;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($media_type_in)) {

                $where[] = 'media.type IN (?)';
                $data[] = $media_type_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($media_type_not_in)) {

                $where[] = 'media.type NOT IN (?)';
                $data[] = $media_type_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END MEDIA TYPE
             */

            /*
             * MEDIA SOURCE
             */
            if (!empty($media_source)) {

                $where[] = 'media.source = ?';
                $data[] = $media_source;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($media_source_in)) {

                $where[] = 'media.source IN (?)';
                $data[] = $media_source_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($media_source_not_in)) {

                $where[] = 'media.source NOT IN (?)';
                $data[] = $media_source_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END MEDIA SOURCE
             */

            /*
             * MEDIA EXTENSION
             */
            if (!empty($media_extension)) {

                $where[] = 'media.extension = ?';
                $data[] = $media_extension;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($media_extension_in)) {

                $where[] = 'media.extension IN (?)';
                $data[] = $media_extension_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($media_extension_not_in)) {

                $where[] = 'media.extension NOT IN (?)';
                $data[] = $media_extension_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            /*
             * END MEDIA EXTENSION
             */

            /*
             * UPLOADER ID
             */
            if (!empty($uploader_id)) {

                $where[] = 'media.uploader_id = ?';
                $data[] = $uploader_id;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($uploader_id_in)) {

                $where[] = 'media.uploader_id IN (?)';
                $data[] = $uploader_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($uploader_id_not_in)) {

                $where[] = 'media.uploader_id NOT IN (?)';
                $data[] = $uploader_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END UPLOADER ID
             */

            /*
             * UPLOADER EMAIL
             */
            if (!empty($uploader_email)) {

                $joins['users'] = 'media.uploader_id = users.id';
                $where[] = ' users.email = ?';
                $data[] = $uploader_email;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($uploader_email_in)) {

                $joins['users'] = 'media.uploader_id = users.id';
                $where[] = 'users.email IN (?)';
                $data[] = $uploader_email_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($uploader_email_not_in)) {

                $joins['users'] = 'media.uploader_id = users.id';
                $where[] = 'users.email NOT IN (?)';
                $data[] = $uploader_email_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END AUTHOR EMAIL
             */

            /*
             * SEARCH QUERY
             */
            if (!empty($s)) {

                $where[] = '(media.title LIKE ? OR media.description LIKE ?)';
                $data[] = '%'.$s.'%';
                $types[] = \PDO::PARAM_STR;
                $data[] = '%'.$s.'%';
                $types[] = \PDO::PARAM_STR;
            }
            /*
             * END SEARCH QUERY
             */

            $limit = intval($per_page);
            $start = intval(($page - 1) * $limit);

            $join_query = '';
            $where_query = '';

            foreach ($joins as $table => $on) {

                $join_query.= " LEFT OUTER JOIN $table ON $on";
            }

            if (!empty($where)) {

                $where_query = ' WHERE '.implode(' AND ', $where);
            }


            if ($count_only) {

                $sql = 'SELECT COUNT(media.id) AS the_count FROM media';
                $start = 0;
                $limit = 1;
            }

            $sql.= "$join_query$where_query ORDER BY {$db->quoteIdentifier($order_by)} $order_dir LIMIT $start, $limit";

            $result = $db->executeQuery($sql, $data, $types);

            if ($count_only && $row = $result->fetch()) {

                $medias = $row['the_count'];
            } else {
                $medias = array();

                while ($media_data = $result->fetch()) {

                    $medias[] = Media::createFromData($media_data);
                }
            }

            if ($cache) {

                $cache->save($key, $medias);
            }
        }

        return $medias;

    }

    /**
     * Gets a Category object based on id or slug.
     *
     * Uses write-through caching.
     *
     * @param int|string $category_identifier The id or slug
     * @return Category|false
     */
    public static function getCategory($category_identifier) {

        $db = self::getDb();
        $cache = self::getCache();
        $category = false;
        $key = 'category/'.$category_identifier;

        if ($cache) {
            $category = $cache->fetch($key);
        }

        if (!$category) {

            $category_data = array();

            if (is_numeric($category_identifier)) {

                $sql = 'SELECT * FROM categories WHERE id = ?';
                $category_data = $db->fetchAssoc($sql, array($category_identifier), array(\PDO::PARAM_INT));


            } else {

                $sql = 'SELECT * FROM categories WHERE slug = ?';
                $category_data = $db->fetchAssoc($sql, array($category_identifier), array(\PDO::PARAM_STR));

            }

            if (!empty($category_data)) {

                $category = new Category($category_data);

                if ($cache) {
                    $cache->save('category/'.$category->id, $category);
                    $cache->save('category/'.$category->slug, $category);

                }
            }

        }

        return $category;

    }

    /**
     * Gets an array of Category objects based on arguments.
     *
     * Uses generational caching.
     *
     * @param array $args
     * @return Category[]|int
     */
    public static function getCategories($args = array()) {


        $db = self::getDb();
        $cache = self::getCache();
        $categories = false;
        $args = self::filterArgsArrays($args);
        $key = 'categories/'.self::getGenerationForDataType('post').'/'.md5(json_encode($args));

        if ($cache) {

            $categories = $cache->fetch($key);
        }

        if (!$categories) {

            $categories = array();

            $count_only = false;
            $page = 1;
            $per_page = 30;
            $order_by = 'categories.date_updated';
            $order_dir = 'DESC';

            extract($args);

            if (empty($order_dir) || $order_dir != 'DESC') {
                $order_dir = 'ASC';
            }

            $sql = 'SELECT categories.* FROM categories';

            $joins = array();
            $where = array();
            $data = array();
            $types = array();

            /*
             * CATEGORY ID
             */

            if (!empty($category_id_in)) {

                $where[] = 'categories.id IN (?)';
                $data[] = $category_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($category_id_not_in)) {

                $where[] = 'categories.id NOT IN (?)';
                $data[] = $category_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END CATEGORY ID
             */

            /*
             * CATEGORY SLUG
             */

            if (!empty($category_slug_in)) {

                $where[] = 'categories.slug IN (?)';
                $data[] = $category_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($category_slug_not_in)) {

                $where[] = 'categories.slug NOT IN (?)';
                $data[] = $category_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END CATEGORY SLUG
             */

            /*
             * POST ID
             */
            if (!empty($post_id)) {

                $joins['posts_categories'] = 'categories.id = posts_categories.category_id';
                $where[] = 'posts_categories.post_id = ?';
                $data[] = $post_id;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($post_id_in)) {

                $joins['posts_categories'] = 'categories.id = posts_categories.category_id';
                $where[] = 'posts_categories.post_id IN (?)';
                $data[] = $post_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($post_id_not_in)) {

                $joins['posts_categories'] = 'categories.id = posts_categories.category_id';
                $where[] = 'posts_categories.post_id NOT IN (?)';
                $data[] = $post_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($post_id_and)) {

                $joins['posts_categories'] = 'categories.id = posts_categories.category_id';
                $local_where = array();

                foreach ($post_id_and as $post_id) {

                    $local_where[] = 'posts_categories.post_id = ?';
                    $data[] = $post_id;
                    $types[] = \PDO::PARAM_INT;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END POST ID
             */

            /*
             * POST SLUG
             */
            if (!empty($post_slug)) {

                $joins['posts_categories'] = 'categories.id = posts_categories.category_id';
                $joins['posts'] = 'posts_categories.post_id = posts.id';

                $where[] = 'posts.slug = ?';
                $data[] = $post_slug;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($post_slug_in)) {

                $joins['posts_categories'] = 'categories.id = posts_categories.category_id';
                $joins['posts'] = 'posts_categories.post_id = posts.id';

                $where[] = 'posts.slug IN (?)';
                $data[] = $post_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($post_slug_not_in)) {

                $joins['posts_categories'] = 'categories.id = posts_categories.category_id';
                $joins['posts'] = 'posts_categories.post_id = posts.id';

                $where[] = 'posts.slug NOT IN (?)';
                $data[] = $post_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($post_slug_and)) {

                $joins['posts_categories'] = 'categories.id = posts_categories.category_id';
                $joins['posts'] = 'posts_categories.post_id = posts.id';

                $local_where = array();

                foreach ($post_slug_and as $post_slug) {

                    $local_where[] = 'posts.slug = ?';
                    $data[] = $post_slug;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END POST SLUG
             */

            /*
             * SEARCH QUERY
             */
            if (!empty($s)) {

                $where[] = 'categories.title LIKE ?';
                $data[] = '%'.$s.'%';
                $types[] = \PDO::PARAM_STR;
            }
            /*
             * END SEARCH QUERY
             */

            $limit = intval($per_page);
            $start = intval(($page - 1) * $limit);

            $join_query = '';
            $where_query = '';

            foreach ($joins as $table => $on) {

                $join_query.= " LEFT OUTER JOIN $table ON $on";
            }

            if (!empty($where)) {

                $where_query = ' WHERE '.implode(' AND ', $where);
            }


            if ($count_only) {

                $sql = 'SELECT COUNT(categories.id) AS the_count FROM categories';
                $start = 0;
                $limit = 1;
            }

            $sql.= "$join_query$where_query ORDER BY {$db->quoteIdentifier($order_by)} $order_dir LIMIT $start, $limit";

            $result = $db->executeQuery($sql, $data, $types);

            if ($count_only && $row = $result->fetch()) {

                $categories = $row['the_count'];
            } else {
                $categories = array();

                while ($category_data = $result->fetch()) {

                    $categories[] = new Category($category_data);
                }
            }


            if ($cache) {

                $cache->save($key, $categories);
            }
        }

        return $categories;
    }

    /**
     * Gets a Section object based on id or slug.
     *
     * Uses write-through caching.
     *
     * @param int|string $section_identifier The id or slug.
     * @return Section|bool
     */
    public static function getSection($section_identifier) {

        $db = self::getDb();
        $cache = self::getCache();
        $section = false;
        $key = 'section/'.$section_identifier;

        if ($cache) {
            $section = $cache->fetch($key);
        }

        if (!$section) {

            $section_data = array();

            if (is_numeric($section_identifier)) {

                $sql = 'SELECT * FROM sections WHERE id = ?';
                $section_data = $db->fetchAssoc($sql, array($section_identifier), array(\PDO::PARAM_INT));


            } else {

                $sql = 'SELECT * FROM sections WHERE slug = ?';
                $section_data = $db->fetchAssoc($sql, array($section_identifier), array(\PDO::PARAM_STR));

            }

            if (!empty($section_data)) {

                $section = new Section($section_data);

                if ($cache) {
                    $cache->save('section/'.$section->id, $section);
                    $cache->save('section/'.$section->slug, $section);
                }

            }
        }

        return $section;

    }

    /**
     * Gets an array of Sections based on arguments.
     *
     * @param array $args
     * @return Section[]|int
     */
    public static function getSections($args = array()) {

        $db = self::getDb();
        $cache = self::getCache();
        $sections = false;
        $args = self::filterArgsArrays($args);
        $key = 'sections/'.self::getGenerationForDataType('post').'/'.md5(json_encode($args));

        if ($cache) {

            $sections = $cache->fetch($key);
        }

        if (!$sections) {

            $sections = array();

            $count_only = false;
            $page = 1;
            $per_page = 30;
            $order_by = 'sections.date_updated';
            $order_dir = 'DESC';

            extract($args);

            if (empty($order_dir) || $order_dir != 'DESC') {
                $order_dir = 'ASC';
            }

            $sql = 'SELECT sections.* FROM sections';

            $joins = array();
            $where = array();
            $data = array();
            $types = array();

            /*
             * SECTION ID
             */

            if (!empty($section_id_in)) {

                $where[] = 'sections.id IN (?)';
                $data[] = $section_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($section_id_not_in)) {

                $where[] = 'sections.id NOT IN (?)';
                $data[] = $section_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END SECTION ID
             */

            /*
             * SECTION SLUG
             */

            if (!empty($section_slug_in)) {

                $where[] = 'sections.slug IN (?)';
                $data[] = $section_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($section_slug_not_in)) {

                $where[] = 'sections.slug NOT IN (?)';
                $data[] = $section_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END SECTION SLUG
             */

            /*
             * POST ID
             */
            if (!empty($post_id)) {

                $joins['posts_sections'] = 'sections.id = posts_sections.section_id';
                $where[] = 'posts_sections.post_id = ?';
                $data[] = $post_id;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($post_id_in)) {

                $joins['posts_sections'] = 'sections.id = posts_sections.section_id';
                $where[] = 'posts_sections.post_id IN (?)';
                $data[] = $post_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($post_id_not_in)) {

                $joins['posts_sections'] = 'sections.id = posts_sections.section_id';
                $where[] = 'posts_sections.post_id NOT IN (?)';
                $data[] = $post_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($post_id_and)) {

                $joins['posts_sections'] = 'sections.id = posts_sections.section_id';
                $local_where = array();

                foreach ($post_id_and as $post_id) {

                    $local_where[] = 'posts_sections.post_id = ?';
                    $data[] = $post_id;
                    $types[] = \PDO::PARAM_INT;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END POST ID
             */

            /*
             * POST SLUG
             */
            if (!empty($post_slug)) {

                $joins['posts_sections'] = 'sections.id = posts_sections.section_id';
                $joins['posts'] = 'posts_sections.post_id = posts.id';

                $where[] = 'posts.slug = ?';
                $data[] = $post_slug;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($post_slug_in)) {

                $joins['posts_sections'] = 'sections.id = posts_sections.section_id';
                $joins['posts'] = 'posts_sections.post_id = posts.id';

                $where[] = 'posts.slug IN (?)';
                $data[] = $post_slug_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($post_slug_not_in)) {

                $joins['posts_sections'] = 'sections.id = posts_sections.section_id';
                $joins['posts'] = 'posts_sections.post_id = posts.id';

                $where[] = 'posts.slug NOT IN (?)';
                $data[] = $post_slug_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($post_slug_and)) {

                $joins['posts_sections'] = 'sections.id = posts_sections.section_id';
                $joins['posts'] = 'posts_sections.post_id = posts.id';

                $local_where = array();

                foreach ($post_slug_and as $post_slug) {

                    $local_where[] = 'posts.slug = ?';
                    $data[] = $post_slug;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END POST SLUG
             */

            /*
             * SEARCH QUERY
             */
            if (!empty($s)) {

                $where[] = 'sections.title LIKE ?';
                $data[] = '%'.$s.'%';
                $types[] = \PDO::PARAM_STR;
            }
            /*
             * END SEARCH QUERY
             */

            $limit = intval($per_page);
            $start = intval(($page - 1) * $limit);

            $join_query = '';
            $where_query = '';

            foreach ($joins as $table => $on) {

                $join_query.= " LEFT OUTER JOIN $table ON $on";
            }

            if (!empty($where)) {

                $where_query = ' WHERE '.implode(' AND ', $where);
            }


            if ($count_only) {

                $sql = 'SELECT COUNT(sections.id) AS the_count FROM sections';
                $start = 0;
                $limit = 1;
            }

            $sql.= "$join_query$where_query ORDER BY {$db->quoteIdentifier($order_by)} $order_dir LIMIT $start, $limit";

            $result = $db->executeQuery($sql, $data, $types);

            if ($count_only && $row = $result->fetch()) {

                $sections = $row['the_count'];
            } else {
                $sections = array();

                while ($section_data = $result->fetch()) {

                    $sections[] = new Section($section_data);
                }
            }


            if ($cache) {

                $cache->save($key, $sections);
            }
        }

        return $sections;
    }

    /**
     * Gets a User based on id or email.
     *
     * Uses write-through caching.
     *
     * @param int|string $user_identifier The id or email.
     * @return User|bool
     */
    public static function getUser($user_identifier) {

        $db = self::getDb();
        $cache = self::getCache();
        $user = false;
        $key = 'user/'.$user_identifier;

        if ($cache) {
            $user = $cache->fetch($key);
        }

        if (!$user) {

            $user_data = array();

            if (is_numeric($user_identifier)) {

                $sql = 'SELECT * FROM users WHERE id = ?';
                $user_data = $db->fetchAssoc($sql, array($user_identifier), array(\PDO::PARAM_INT));


            } else {

                $sql = 'SELECT * FROM users WHERE email = ?';
                $user_data = $db->fetchAssoc($sql, array($user_identifier), array(\PDO::PARAM_STR));

            }

            if (!empty($user_data)) {

                unset($user_data['password']);
                $user = new User($user_data);

                if ($cache) {
                    $cache->save('user/'.$user->id, $user);
                    $cache->save('user/'.$user->email, $user);
                }
            }
        }

        return $user;
    }

    /**
     * Gets a User based on token.
     *
     * Uses write-through caching.
     *
     * @param string $token The User's token.
     * @return User|bool
     */
    public static function getUserFromToken($token) {

        $db = self::getDb();
        $cache = self::getCache();
        $user = false;
        $key = 'user/'.$token;

        if ($cache) {
            $user = $cache->fetch($key);
        }

        if (!$user) {

            $sql = 'SELECT users.*
                    FROM users
                    JOIN users_tokens
                    ON users.id = users_tokens.user_id
                    WHERE users_tokens.token = ?
                    AND users_tokens.unixtime_expires > ?';

            $user_data = $db->fetchAssoc($sql, array($token, time()), array(\PDO::PARAM_STR, \PDO::PARAM_INT));

            if (!empty($user_data)) {

                unset($user_data['password']);
                $user = new User($user_data);

                if ($cache) {
                    $cache->save('user/'.$user->id, $user);
                    $cache->save('user/'.$user->email, $user);
                    $cache->save('user/'.$token, $user);
                }
            }
        }

        return $user;
    }

    /**
     * Gets an array of Users based on arguments.
     *
     * Uses generational caching.
     *
     * @param array $args
     * @return User[]
     */
    public static function getUsers($args = array()) {


        $db = self::getDb();
        $cache = self::getCache();
        $users = false;
        $args = self::filterArgsArrays($args);
        $key = 'users/'.self::getGenerationForDataType('user').'/'.md5(json_encode($args));

        if ($cache) {

            $users = $cache->fetch($key);
        }

        if (!$users) {

            $users = array();

            $count_only = false;
            $page = 1;
            $per_page = 30;
            $status = Core::STATUS_PUBLISHED;
            $order_by = 'users.date_updated';
            $order_dir = 'DESC';

            extract($args);

            if (empty($order_dir) || $order_dir != 'DESC') {
                $order_dir = 'ASC';
            }

            $sql = 'SELECT users.* FROM users';

            $joins = array();
            $where = array();
            $data = array();
            $types = array();

            /*
             * USER ID
             */

            if (!empty($user_id_in)) {

                $where[] = 'users.id IN (?)';
                $data[] = $user_id_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($user_id_not_in)) {

                $where[] = 'users.id NOT IN (?)';
                $data[] = $user_id_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END USER ID
             */

            /*
             * USER EMAIL
             */

            if (!empty($user_email_in)) {

                $where[] = 'users.email IN (?)';
                $data[] = $user_email_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($user_email_not_in)) {

                $where[] = 'users.email NOT IN (?)';
                $data[] = $user_email_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }
            /*
             * END USER EMAIL
             */

            /*
             * USER TYPE
             */
            if (!empty($user_type)) {

                $where[] = 'users.type = ?';
                $data[] = $user_type;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($user_type_in)) {

                $where[] = 'users.type IN (?)';
                $data[] = $user_type_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($user_type_not_in)) {

                $where[] = 'users.type NOT IN (?)';
                $data[] = $user_type_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END USER TYPE
             */

            /*
              * META TITLE
              */
            if (!empty($meta_title)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.title = ?';
                $data[] = $meta_title;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($meta_title_in)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.title IN (?)';
                $data[] = $meta_title_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_title_not_in)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.title NOT IN (?)';
                $data[] = $meta_title_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_title_and)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';

                $local_where = array();

                foreach ($meta_title_and as $meta_title) {

                    $local_where[] = 'users_meta.title = ?';
                    $data[] = $meta_title;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END META TITLE
             */

            /*
             * META VALUE
             */
            if (!empty($meta_value)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.value = ?';
                $data[] = $meta_value;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($meta_value_in)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.value IN (?)';
                $data[] = $meta_value_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_value_not_in)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.value NOT IN (?)';
                $data[] = $meta_value_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_value_and)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';

                $local_where = array();

                foreach ($meta_value_and as $meta_value) {

                    $local_where[] = 'users_meta.value = ?';
                    $data[] = $meta_value;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END META VALUE
             */

            /*
             * META TYPE
             */
            if (!empty($meta_type)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.type = ?';
                $data[] = $meta_type;
                $types[] = \PDO::PARAM_STR;
            }

            if (!empty($meta_type_in)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.type IN (?)';
                $data[] = $meta_type_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_type_not_in)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';
                $where[] = 'users_meta.type NOT IN (?)';
                $data[] = $meta_type_not_in;
                $types[] = Connection::PARAM_STR_ARRAY;
            }

            if (!empty($meta_type_and)) {

                $joins['users_meta'] = 'users.id = users_meta.user_id';

                $local_where = array();

                foreach ($meta_type_and as $meta_type) {

                    $local_where[] = 'users_meta.type = ?';
                    $data[] = $meta_type;
                    $types[] = \PDO::PARAM_STR;
                }
                $where[] = '('.implode(' AND ', $local_where).')';
            }
            /*
             * END META TYPE
             */

            /*
             * STATUS
             */
            if (!empty($status)) {

                $where[] = 'users.status = ?';
                $data[] = $status;
                $types[] = \PDO::PARAM_INT;
            }

            if (!empty($status_in)) {

                $where[] = 'users.status IN(?)';
                $data[] = $status_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }

            if (!empty($status_not_in)) {

                $where[] = 'users.status NOT IN(?)';
                $data[] = $status_not_in;
                $types[] = Connection::PARAM_INT_ARRAY;
            }
            /*
             * END STATUS
             */

            /*
             * SEARCH QUERY
             */
            if (!empty($s)) {

                $where[] = '(users.email LIKE ?
                            OR users.first_name LIKE ?
                            OR users.last_name LIKE ?
                            OR users.display_name LIKE ?)';

                for ($x = 0; $x < 4; $x++) {

                    $data[] = '%'.$s.'%';
                    $types[] = \PDO::PARAM_STR;
                }

            }
            /*
             * END SEARCH QUERY
             */

            $limit = intval($per_page);
            $start = intval(($page - 1) * $limit);

            $join_query = '';
            $where_query = '';

            foreach ($joins as $table => $on) {

                $join_query.= " LEFT OUTER JOIN $table ON $on";
            }

            if (!empty($where)) {

                $where_query = ' WHERE '.implode(' AND ', $where);
            }




            if ($count_only) {

                $sql = 'SELECT COUNT(users.id) AS the_count FROM users';
                $start = 0;
                $limit = 1;
            }

            $sql.= "$join_query$where_query ORDER BY {$db->quoteIdentifier($order_by)} $order_dir LIMIT $start, $limit";

            $result = $db->executeQuery($sql, $data, $types);

            if ($count_only && $row = $result->fetch()) {

                $users = $row['the_count'];
            } else {
                $users = array();

                while ($user_data = $result->fetch()) {

                    $users[] = new User($user_data);
                }
            }

            if ($cache) {

                $cache->save($key, $users);
            }
        }

        return $users;


    }

    /**
     * Gets the Meta object for a User.
     *
     * Uses write-through caching.
     *
     * @param int $user_id
     * @return Meta[]
     */
    public static function getUserMeta($user_id) {

        $db = self::getDb();
        $cache = self::getCache();
        $meta = false;
        $key = 'user/'.$user_id.'/meta';

        if ($cache) {

            $meta = $cache->fetch($key);
        }

        if (!$meta || !($meta instanceof Meta)) {

            $meta = new Meta();

            $sql = 'SELECT *
                    FROM users_meta
                    WHERE user_id = ?
                    ORDER BY id ASC';

            $result = $db->executeQuery($sql, array($user_id), array(\PDO::PARAM_INT));

            while ($meta_data = $result->fetch()) {

                $meta->add($meta_data);
            }

            if ($cache) {
                $cache->save($key, $meta);
            }
        }
        return $meta;
    }

    public static function logoutUser() {

        $db = self::getDb();

        Core::startSession();

        $user = self::getCurrentUser();

        if ($user) {

            $sql = 'DELETE FROM users_tokens WHERE user_id = ?';
            $db->executeQuery($sql, array($user->id), array(\PDO::PARAM_INT));

            if (!empty($_SESSION['token'])) {

                unset($_SESSION['token']);
            }
        }
    }

    /**
     * @param string $email User's email.
     * @param string $password User's password (unhashed).
     * @param string $ip_address Optional IP address.
     * @param string $user_agent Optional User Agent.
     * @return User|bool Returns User on success.
     */
    public static function loginUser ($email, $password, $ip_address = '', $user_agent = '') {

        $db = self::getDb();

        $sql = 'SELECT id,password FROM users WHERE email = ?';

        $user_data = $db->fetchAssoc($sql, array($email), array(\PDO::PARAM_STR));

        if (empty($user_data)) {

            self::addAlert('User does not exist.', self::ALERT_TYPE_ERROR);
        } else {
            $user_id = $user_data['id'];
            $hashed_password = $user_data['password'];
            $hasher = new Hash();

            if (!empty($hashed_password) && $hasher->checkPassword($password, $hashed_password)) {

                $token = self::makeToken();
                $one_month = time() + (60 * 60 * 24 * 31);
                $insert = array(
                    'user_id' => $user_id,
                    'token' => $token,
                    'ip_address' => $ip_address,
                    'user_agent' => $user_agent,
                    'unixtime_added' => time(),
                    'unixtime_expires' => $one_month
                );

                $db->insert('users_tokens', $insert);
                $sql = 'DELETE FROM users_tokens WHERE user_id = ? AND unixtime_expires < ?';
                $db->executeQuery($sql, array($user_id, time()), array(\PDO::PARAM_INT, \PDO::PARAM_INT));

                Core::startSession();

                //$_SESSION['user_id'] = $user_id;
                $_SESSION['token'] = $token;

                return self::getCurrentUser();
            } else {

                self::addAlert('Incorrect password.', self::ALERT_TYPE_ERROR);

            }

        }
        return false;
    }

    /**
     * @return User|false Returns current logged in User on success.
     */
    public static function getCurrentUser() {

        if (empty(self::$current_user)) {

            Core::startSession();

            if (!empty($_SESSION['token'])) {

                self::$current_user = self::getUserFromToken($_SESSION['token']);
            } else {
                self::$current_user = false;
            }
        }
        return self::$current_user;
    }

    /**
     * @param array $user_data
     * @return User|bool Returns new User on success.
     */
    public static function addNewUser($user_data) {

        $db = self::getDb();

        Validator::addRule('password', function($field, $value, array $params) {

                return User::isAcceptablePassword($value);

            }, 'Password must be at least 6 characters long');

        $validator = self::getValidator($user_data);
        $validator->rule('required', array('email', 'password'));
        $validator->rule('email', 'email');
        $validator->rule('password', 'password');

        if ($validator->validate()) {

            $email = trim($user_data['email']);

            $sql = 'SELECT COUNT(id) FROM users WHERE email = ?';

            $exists = intval($db->fetchColumn($sql, array($email)));

            if (!$exists) {

                $password = $user_data['password'];
                unset($user_data['password']);
                $new_user = new User($user_data);

                if ($new_user_id = $new_user->save()) {

                    if ($new_user->changePassword($password)) {

                        return $new_user;
                    }
                }
            } else {
                Core::addAlert('User already exists for this email address.', Core::ALERT_TYPE_ERROR);
            }

        }
        return false;
    }

    /**
     * @param int|string $user_identifier User id or email.
     * @param array $new_user_data Associative array of new data to enter.
     * @return int|bool Returns User id on success.
     */
    public static function changeUserData($user_identifier, $new_user_data) {

        $db = self::getDb();

        $user = self::getUser($user_identifier);

        if ($user) {

            $user = new User($new_user_data);

            if ($user_id = $user->save()) {

                if (!empty($new_user_data['password']) && User::isAcceptablePassword($new_user_data['password'])) {

                    $user_id = $user->changePassword($new_user_data['password']);
                }

                return $user_id;
            }

        }
        return false;
    }

    /**
     * @param array $fields Associative array of form data.
     * @param string|null $lang Language to use.
     * @param string|null $langDir Directory of language file.
     * @return Validator
     */
    public static function getValidator($fields, $lang = null, $langDir = null) {

        return new Validator($fields, $lang, $langDir);
    }

    /**
     * @param string $data_type e.g. post, category, section, media, etc.
     * @return int Generation number.
     */
    public static function getGenerationForDataType ($data_type) {

        $generation = 0;
        $generations = self::getGenerations();

        if ( !empty($generations[$data_type]) ) {

            $generation = $generations[$data_type];
        }
        return $generation;
    }

    /**
     * @return int[] Associative array of generations, indexed by data type  e.g. post, category, section, media, etc.
     */
    public static function getGenerations()
    {
        $db = self::getDb();
        $cache = self::getCache();

        $generations = array();


        if ($cache) {
            $generations = $cache->fetch('generations');
        } else {
            $generations = false;
        }

        if (!$generations) {

            $sql = 'SELECT data_type, generation_count
                    FROM cache_generations';

            $result = $db->executeQuery($sql);

            while ($generation = $result->fetch()) {

                $generations[$generation['data_type']] = $generation['generation_count'];
            }
            if ($cache) {
                $cache->save('generations', $generations);
            }

        }

        return $generations;
    }

    /**
     * @param string $data_type  e.g. post, category, section, media, etc.
     */
    public static function incrementGeneration($data_type)
    {
        $db = self::getDb();

        $cache = self::getCache();

        $sql = 'UPDATE cache_generations
                SET generation_count = generation_count + 1
                WHERE data_type = ? OR data_type = ?';

       $count = $db->executeUpdate($sql, array($data_type, 'post'));

        if (!$count) {

            $data = array(
                'generation_count' => 1,
                'data_type' => $data_type
            );
            $db->insert('cache_generations', $data);

        }

        if ($cache) {

            $cache->delete('generations');
        }
    }

    /**
     * Can return a unique string for any object.
     *
     * @param mixed $value
     * @return string
     */
    public static function customSerialize($value)
    {

        ob_start();

        var_dump($value);
        $unique_string = ob_get_clean();

        return md5($unique_string);
    }


    /**
     * @return bool|Solarium\Client
     */
    public static function getSolr()
    {
        if (defined('SOLR_HOST')
            && defined('SOLR_PORT')
            && defined('SOLR_PATH')) {


            $solr_config = array(
                'endpoint' => array(
                    'localhost' => array(
                        'host' => SOLR_HOST,
                        'port' =>SOLR_PORT,
                        'path' =>SOLR_PATH,
                    )
                )
            );

            // execute the ping query
            try{
                // create a client instance
                $solr = new Solarium\Client($solr_config);
                return $solr;

            } catch(Solarium\Exception $e){

            }

        }
        return false;
    }


    /**
     * Doctrine Common cache object.
     *
     * Documentation here: http://docs.doctrine-project.org/en/2.0.x/reference/caching.html
     *
     * @return bool|ApcCache|MemcacheCache
     */
    public static function getCache() {

        if (empty(self::$cache)) {

            if (CACHE_DRIVER == CACHE_DRIVER_APC) {

                if(extension_loaded('apc') && ini_get('apc.enabled')) {

                    try{
                        self::$cache = new ApcCache();

                    } catch(\Exception $e){

                        self::$cache = false;
                    }

                }

            } elseif (CACHE_DRIVER == CACHE_DRIVER_MEMCACHED) {

                if (defined('MEMCACHE_HOST') && defined('MEMCACHE_PORT')) {

                    try{
                        $memcached = new Memcached();

                        if ( $memcached->addServer(MEMCACHE_HOST, MEMCACHE_PORT) ) {


                            self::$cache = new MemcachedCache();
                            self::$cache->setMemcached($memcached);
                        }

                    } catch(\Exception $e){

                        self::$cache = false;
                    }

                }


            } elseif (CACHE_DRIVER == CACHE_DRIVER_MEMCACHE) {


                if (defined('MEMCACHE_HOST') && defined('MEMCACHE_PORT')) {

                    try{
                        $memcache = new Memcache();

                        if ( $memcache->connect(MEMCACHE_HOST, MEMCACHE_PORT) ) {


                            self::$cache = new MemcacheCache();
                            self::$cache->setMemcache($memcache);
                        }

                    } catch(\Exception $e){

                        self::$cache = false;
                    }

                }


            } elseif (CACHE_DRIVER_XCACHE) {

                try{
                    self::$cache = new XcacheCache();

                } catch(\Exception $e){

                    self::$cache = false;
                }

            }

        }

        //return false;
        return self::$cache;
    }

    /**
     * @param string $text String to convert to url-safe.
     * @return string Url-safe version of $text.
     */
    public static function slugify($text)
    {
        //put in spaces after capital letters
        $regex = '/(?<!^)((?<![[:upper:]])[[:upper:]]|[[:upper:]](?![[:upper:]]))/';
        $text = preg_replace( $regex, ' $1', $text );

        // replace non letter or digits by -
        $text = preg_replace('~[^\\pL\d]+~u', '-', $text);

        // trim
        $text = trim($text, '-');

        // transliterate
        $text = iconv('utf-8', 'us-ascii//TRANSLIT', $text);

        // lowercase
        $text = strtolower($text);

        // remove unwanted characters
        $text = preg_replace('~[^-\w]+~', '', $text);

        if (empty($text))
        {
            return 'n-a';
        }

        return $text;
    }

    /**
     * @param string $slug Url-safe string to convert.
     * @param bool $exclude_first_word Determines if to uppercase the first word or not.
     * @return string ReturnsLikeThis if $exclude_first_word, or likeThis if not.
     */
    public static function slugToCamelCase ($slug, $exclude_first_word = true) {

        $camel_case = '';

        $sanitized = self::slugify($slug);

        $pieces = explode('-', $sanitized);
        $count = count($pieces);

        if ($exclude_first_word) {

            $camel_case = $pieces[0];
        } else {
            $camel_case = ucwords($pieces[0]);
        }

        for ($x = 1; $x < $count; $x++) {

            $camel_case.= ucwords($pieces[$x]);
        }
        return $camel_case;
    }

    /**
     * @param $slug
     * @return bool
     */
    public static function isProperSlug($slug)
    {

        if (!empty($slug) && $slug == urlencode(strtolower($slug))) {
            return true;
        }
        return false;
    }

    /**
     * @param int $status A STATUS constant.
     * @return string String version of status.
     */
    public static function statusToString($status) {

        if (!empty(self::$statuses[$status])) {

            return self::$statuses[$status];
        }
        return 'none';
    }


    /**
     * @param string $content Content so search through.
     * @param int $maxwidth Maximum width of wideo.
     * @return bool|mixed Returns results of oEmbed as associative array
     */
    public static function findVimeoUrl($content, $maxwidth = 400) {

        $valid = false;
        $matches = array();
        preg_match('#(player\.vimeo\.com\/video/([0-9]*)")#', $content, $matches);
        if(!$valid && isset($matches[2]) && $matches[2] != ''){

            $vimeo = 'http://vimeo.com/'.$matches[2];

            $ch = curl_init();
            $open = sprintf('http://vimeo.com/api/oembed.json?url=%s&maxwidth=%s&format=json', urlencode($vimeo),$maxwidth);
            curl_setopt($ch, CURLOPT_URL, $open);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            $output = curl_exec($ch);
            curl_close($ch);
            $valid = json_decode($output, true);
            //$valid =json_decode(file_get_contents(sprintf('http://vimeo.com/api/oembed.json?url=%s&maxwidth=600', urlencode($vimeo))),true);
        }

        preg_match('(vimeo\.com\/([0-9]*))', $content, $matches);
        if(!$valid && isset($matches[1]) && $matches[1] != ''){

            $vimeo = 'http://vimeo.com/'.$matches[1];

            $ch = curl_init();
            $open = sprintf('http://vimeo.com/api/oembed.json?url=%s&maxwidth=%s&format=json', urlencode($vimeo),$maxwidth);
            curl_setopt($ch, CURLOPT_URL, $open);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            $output = curl_exec($ch);
            curl_close($ch);
            $valid = json_decode($output, true);
            //$valid =json_decode(file_get_contents(sprintf('http://vimeo.com/api/oembed.json?url=%s&maxwidth=600', urlencode($vimeo))),true);
        }
        return $valid;
    }

    /**
     * @param string $content Content so search through.
     * @param int $maxwidth Maximum width of wideo.
     * @return bool|mixed Returns results of oEmbed as associative array
     */
    public static function findYoutubeUrl($content, $maxwidth = 400) {

        $matches = array();
        preg_match('#(\.be/|/embed/|/v/|/watch\?v=)([A-Za-z0-9_-]{5,11})#', $content, $matches);
        if(isset($matches[2]) && $matches[2] != ''){

            $youtube = 'http://youtu.be/'.$matches[2];

            $ch = curl_init();
            $open = sprintf('http://www.youtube.com/oembed?url=%s&maxwidth=%s&format=json', urlencode($youtube),$maxwidth);
            curl_setopt($ch, CURLOPT_URL, $open);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            $output = curl_exec($ch);
            curl_close($ch);
            $valid = json_decode($output, true);

            //$valid =json_decode(@file_get_contents(sprintf('http://www.youtube.com/oembed?url=%s&maxwidth=%s&format=json', urlencode($youtube),$maxwidth)),true);
            if($valid && isset($valid['thumbnail_url'])) {

                $valid['video_url'] = $youtube;
                $valid['id'] = $matches[2];
                return $valid;
            }
            else {
                return false;
            }

        }
        else {
            return false;
        }

    }

    /**
     * Creates the JavaScript for tracking a click.
     *
     * Documentation: https://developers.google.com/analytics/devguides/collection/gajs/eventTrackerGuide
     *
     * @param string $category
     * @param string $action
     * @param string|bool $label
     * @param string|bool $value
     * @param string|bool $noninteraction
     * @return string
     */
    public static function googleAnalyticsEventTrackingJS($category, $action, $label = false, $value = false, $noninteraction = false) {


        $args = array("'_trackEvent'");

        $args[]= "'".addslashes($category)."'";
        $args[]= "'".addslashes($action)."'";

        if ($label) {
            $args[]= "'".addslashes($label)."'";
        }
        if ($value) {
            $args[]= "'".addslashes($value)."'";
        }
        if ($noninteraction) {
            $args[]= "'".addslashes($noninteraction)."'";
        }

        return 'onClick="_gaq.push(['.implode(', ', $args).']);"';
    }

    /**
     * Finds GCD (Greatest Common Divisor) of two numbers.
     *
     * @param number $a
     * @param number $b
     * @return int|number
     */
    public static function gcd($a,$b) {
        $a = abs($a); $b = abs($b);
        if( $a < $b) list($b,$a) = Array($a,$b);
        if( $b == 0) return $a;
        $r = $a % $b;
        while($r > 0) {
            $a = $b;
            $b = $r;
            $r = $a % $b;
        }
        return $b;
    }

    /**
     * @param int $num Numerator.
     * @param int $den Denominator.
     * @return array Reduced ratio in an array of [num, den]
     */
    public static function reduceRatio($num, $den) {
        $g = self::gcd($num, $den);
        return array($num/$g,$den/$g);
    }

    /**
     * Generates a token.
     *
     * @return string
     */
    public static function makeToken() {

        mt_srand((double)microtime()*10000);//optional for php 4.2.0 and up.
        $charid = strtoupper(md5(uniqid(rand(), TRUE)));
        $hyphen = chr(45);// "-"
        $uuid =
            //chr(123)// "{"
            time().$hyphen
            .rand().$hyphen
            .microtime().$hyphen
            .rand().$hyphen
            .substr($charid, 0, 8).$hyphen
            .substr($charid, 8, 4).$hyphen
            .substr($charid,12, 4).$hyphen
            .substr($charid,16, 4).$hyphen
            .substr($charid,20,12)
            //.chr(125)
        ;// "}"
        return $uuid;

    }

    /**
     * @param string $haystack String to search in.
     * @param string $needle String to search for.
     * @return bool
     */
    public static function startsWith($haystack, $needle) {
        return $needle === "" || strpos($haystack, $needle) === 0;
    }

    /**
     * @param string $haystack String to search in.
     * @param string $needle String to search for.
     * @return bool
     */
    public static function endsWith($haystack, $needle) {
        return $needle === "" || substr($haystack, -strlen($needle)) === $needle;
    }

    public static function extensionFromFilename($filename) {

        return strtolower( pathinfo( $filename, PATHINFO_EXTENSION ));
    }


    public static function downloadFile($url, $path) {

        $newfname = $path;
        $file = fopen ($url, "rb");
        if ($file) {
            $newf = fopen ($newfname, "wb");

            if ($newf)
                while(!feof($file)) {
                    fwrite($newf, fread($file, 1024 * 8 ), 1024 * 8 );
                }
        }

        if ($file) {
            fclose($file);
        }

        if (!empty($newf)) {
            fclose($newf);
        }
    }

    /**
     * @param string $form_name - The name give to the file input in the form.
     * @param string $upload_path - The full path (filename included) to where you wish to save the file.
     * @param int $max_size_in_bytes
     * @return bool
     */
    public static function uploadFile($form_name, $upload_path, $max_size_in_bytes = 15000000) {

        try {

            // Undefined | Multiple Files | $_FILES Corruption Attack
            // If this request falls under any of them, treat it invalid.
            if (
                !isset($_FILES[$form_name]['error']) ||
                is_array($_FILES[$form_name]['error'])
            ) {
                throw new \RuntimeException('Invalid parameters.');
            }

            // Check $_FILES[$form_name]['error'] value.
            switch ($_FILES[$form_name]['error']) {
                case UPLOAD_ERR_OK:
                    break;
                case UPLOAD_ERR_NO_FILE:
                    throw new \RuntimeException('No file sent.');
                case UPLOAD_ERR_INI_SIZE:
                case UPLOAD_ERR_FORM_SIZE:
                    throw new \RuntimeException('Exceeded filesize limit.');
                default:
                    throw new \RuntimeException('Unknown errors.');
            }

            // You should also check filesize here.
            if ($_FILES[$form_name]['size'] > $max_size_in_bytes) {
                throw new \RuntimeException('Exceeded filesize limit.');
            }

            // You should name it uniquely.
            if (!move_uploaded_file($_FILES[$form_name]['tmp_name'], $upload_path)) {
                throw new \RuntimeException('Failed to move uploaded file.');
            }

            return true;

        } catch (\RuntimeException $e) {

            Core::addAlert($e->getMessage(), Core::ALERT_TYPE_EXCEPTION);

        }


    }

    public static function queueTemporaryFile($path) {

        $temp_paths = array();

        Core::startSession();

        if (!empty($_SESSION['__temp_paths'])) {

            $temp_paths = json_decode($_SESSION['__temp_paths'], true);
        }

        $temp_paths[] = $path;

        $_SESSION['__temp_paths'] = json_encode($temp_paths);
    }

    public static function deleteTemporaryFiles() {

        Core::startSession();

        if (!empty($_SESSION['__temp_paths'])) {

            $temp_paths = json_decode($_SESSION['__temp_paths'], true);

            foreach ($temp_paths as $path) {

                unlink($path);
            }
            unset($_SESSION['__temp_paths']);
        }
    }

    /**
     * @param int $current_page The current page you are on.
     * @param int $total_num_pages The max number of pages you can retrieve for your result set.
     * @param int $num_pages_to_display How many page numbers in the list you want to display.
     * @return int[] array
     */
    public static function getPageList($current_page, $total_num_pages, $num_pages_to_display) {

        $page_list = array(); //the list of page numbers

        if ($current_page > 0 && $current_page <= $total_num_pages) {

            $page_list[] = $current_page; //add current page to the list

            /* if there are less pages than how many you want to display,
               lower the length of the page list
             */
            if ($total_num_pages < $num_pages_to_display) {

                $array_length = $total_num_pages;
            } else {
                $array_length = $num_pages_to_display;
            }

            $count = 1; //total times the loop has ran
            $in_array = 1; //how many pages are in the list
            while ($in_array < $array_length) {

                /*
                 * we will alternate between adding pages lower than the current page
                 * and adding pages higher than the current page by checking if the count
                 * is odd or even
                 */
                if ($count % 2) {

                    $prev_page = $current_page - $count; //how far away from the current page to go back

                    if ($prev_page > 0) { // if the page exists

                        $page_list[] = $prev_page; //add it to the list
                        $in_array++; //keep track of how many are in the list

                    }
                    $current_page = $prev_page; // actually go back
                } else {

                    $next_page = $current_page + $count; //how far away from the current page to move ahead

                    if ($next_page <= $total_num_pages) { // if the page exists

                        $page_list[] = $next_page; //add it to the list
                        $in_array++; //keep track of how many are in the list
                    }
                    $current_page = $next_page; //actually move ahead
                }
                $count++;
            }
            sort($page_list); //sort all the pages you have added

        }
        return $page_list;
    }

    public static function filterArgsArrays($args = array()) {

        foreach ($args as $key => $value) {

            if (is_array($value)) {

                $filtered = array_filter($value);

                $args[$key] = $filtered;
            }
        }

        return $args;
    }

}
 